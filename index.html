<!DOCTYPE html>
<html lang="en">
<head>
  <meta http-equiv="Content-Security-Policy" content="
  default-src 'self' https://corsproxy.io;
  script-src 'self' 'unsafe-inline';
  style-src 'self' 'unsafe-inline';
  img-src 'self' data:;
  connect-src 'self' https://corsproxy.io;
  worker-src 'self';
">
  <meta http-equiv="Cache-Control" content="no-store, no-cache, must-revalidate, max-age=0">
    <meta http-equiv="Cache-Control" content="post-check=0, pre-check=0">
    <meta http-equiv="Pragma" content="no-cache">
    <meta http-equiv="Expires" content="0">    
    <meta name="referrer" content="no-referrer" />
    <link rel="manifest" href="manifest.json" />
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Browse.html</title>x`
    <style>
        body {  
            margin: 0;
            padding: 0;
            font-family: Arial, sans-serif;
            background-color: #f6f6f6;
            overflow: hidden;
        }

        #browser {
            display: flex;
            flex-direction: column;
            height: 100vh;
        }

        #chrome-bar {
            background-color: #f1f1f1;
            padding: 8px;
            display: flex;
            align-items: center;
            justify-content: space-between;
            position: fixed;
            top: 0;
            left: 0;
            right: 0;
            z-index: 2;
        }

        #back-button,
        #forward-button,
        #refresh-button {
            background-color: #fff;
            border: none;
            margin-right: 8px;
            cursor: pointer;
            font-size: 20px;
        }

        #back-button::before {
            content: "←"; /* Left arrow: &#8592; */
        }

        #forward-button::before {
            content: "→"; /* Right arrow: &#8594; */
        }

        #refresh-button::before {
            content: "↺"; /* Circular arrow: &#8635; */
        }

        #url-input {
            flex: 1;
            border: none;
            padding: 6px;
            margin: 0;
            font-size: 16px;
            outline: none;
        }

        #url-input:focus {
            border-bottom: 2px solid #0078d4;
        }

        #content {
            flex: 1;
            overflow: auto;
            position: relative;
        }

        #webpage {
            width: 100%;
            height: 100%;
            border: none;
        }
    </style>
</head>
<body>
    <div id="browser">
        <div id="chrome-bar">
            <button id="back-button" disabled></button>
            <button id="forward-button" disabled></button>
            <button id="refresh-button"></button>
            <input id="url-input" type="text" value="https://www.wikipedia.org">
        </div>
        <div id="content">
            <iframe sandbox="allow-scripts allow-forms" id="webpage" frameborder="0"></iframe>
        </div>
    </div>

    <script id="x_loader">

    // Check if the browser supports service workers
    if ('serviceWorker' in navigator) {
      window.addEventListener('load', () => {
        navigator.serviceWorker.register('/serviceworker.js')
          .then(registration => {
            console.log('Service Worker registered:', registration);
          })
          .catch(error => {
            console.log('Service Worker registration failed:', error);
          });
      });

     // This variable will save the event for later use.
    let deferredPrompt;
    window.addEventListener('beforeinstallprompt', (e) => {
      // Prevents the default mini-infobar or install dialog from appearing on mobile
      e.preventDefault();
      // Save the event because you'll need to trigger it later.
      deferredPrompt = e;
      // Show your customized install prompt for your PWA
      // Your own UI doesn't have to be a single element, you
      // can have buttons in different locations, or wait to prompt
      // as part of a critical journey.
      showInAppInstallPromotion();
});

   }

      window.x_proxy =  "https://corsproxy.io/?";

      window.addEventListener('securitypolicyviolation', function(event) {
        //recovering from csp violation:
        //console.log('CSP Violation:', event);
      
        // Fetch the blocked resource using a CORS proxy
        fetchWithProxy(event.blockedURI)
          .then(response => response.text())
          .then(data => {

          // Check if the source is an iframe
          if (frameElement.tagName === 'IFRAME') {
          const iframeDocument = event.source.document;
            iframeDocument.open();
            iframeDocument.write(data);
            iframeDocument.close();
          }

          // Check if the source is an image
        else if (frameElement.tagName === 'IMG') {
          // Assuming data is binary image data
          fetch('your_image_url')
            .then(response => {
              const contentType = response.headers.get('content-type');
              return response.arrayBuffer();
            })
            .then(binaryImage => {
              const base64Image = btoa(String.fromCharCode.apply(null, new Uint8Array(binaryImage)));
              frameElement.src = `data:${contentType};base64,${base64Image}`;
            })
            .catch(error => {
              console.error('Error fetching image:', error);
            });
        }

        // Check if the source is a link to a CSS file
        else if (frameElement.tagName === 'LINK' && frameElement.getAttribute('rel') === 'stylesheet') {
          // Assuming data is binary CSS data
          const binaryCss = data;
          const base64Css = btoa(String.fromCharCode.apply(null, binaryCss));
          const styleTag = document.createElement('style');
          styleTag.textContent = atob(base64Css); // Decode from Base64 and set as text content
          document.head.appendChild(styleTag);
        }

        // Check if the source is a video
        else if (frameElement.tagName === 'VIDEO') {
          // Assuming data is binary video data
          fetch('your_video_url')
            .then(response => {
              const contentType = response.headers.get('content-type');
              return response.arrayBuffer();
            })
            .then(binaryVideo => {
              const base64Video = btoa(String.fromCharCode.apply(null, new Uint8Array(binaryVideo)));
              frameElement.src = `data:${contentType};base64,${base64Video}`;
            })
            .catch(error => {
              console.error('Error fetching video:', error);
            });
        }

          })
          .catch(error => {
            console.error('Error fetching data through proxy:', error);
          });
      });
      
      function fetchWithProxy(url) {
        // Use the CORS proxy to fetch the resource
     //const corsProxyUrl = 'https://corsproxy.io/?';
       if(url.startsWith(window.x_proxy)){
        console.log("Fetching:"+window.x_proxy);
         return fetch(url);
        }else{
          console.log("fetching:"+window.x_proxy+url);
          return fetch(window.x_proxy+url);{
        }
      }

      function handleFetchedData(data) {
        // Handle the fetched data as needed, for example, inject it into the DOM
        // Replace this with your actual logic
        const resultContainer = document.getElementById('result-container');
        resultContainer.textContent = data;
      }

      const CACHE_NAME = 'my-cache-v1';

self.addEventListener('install', event => {
  event.waitUntil(
    caches.open(CACHE_NAME).then(cache => {
      // Nothing to cache during installation
      return;
    })
  );
});

self.addEventListener('fetch', event => {
  event.respondWith(
    caches.match(event.request).then(response => {
      return response || fetch(event.request).then(fetchResponse => {
        // Check if we received a valid response
        if (!fetchResponse || fetchResponse.status !== 200 || fetchResponse.type !== 'basic') {
          return fetchResponse;
        }

        // Clone the response as it can be read only once
        const responseToCache = fetchResponse.clone();

        caches.open(CACHE_NAME).then(cache => {
          cache.put(event.request, responseToCache);
        });

        return fetchResponse;
      }).catch(error => {
        // Handle fetch errors here, e.g., log the error
        console.error('Error fetching:', error);
      });
    })
  );
});

self.addEventListener('activate', event => {
  event.waitUntil(
    caches.keys().then(cacheNames => {
      return Promise.all(
        cacheNames.map(cacheName => {
          if (cacheName !== CACHE_NAME) {
            return caches.delete(cacheName);
          }
        })
      );
    })
  );
});


        Object.defineProperty(document, 'cookie', {
          get: function() {
            return (document._cookie || '');
          },
          set: function(cookieString) {
            document._cookie = cookieString;
          }
        });
      
        window.addEventListener('error', function(e) {
            console.log("parent window global exception:",e);
          });
          document.addEventListener('error', function(e) {
            console.log("parent window global exception:",e);
          });
      
        /*
          window.addEventListener("beforeunload", function(event) {
            console.log("!going:",event.target);
            event.preventDefault();
            event['returnValue']="Click Cancle to Keep Your Reward Questions.";
          });
      window.addEventListener('pushstate', pushUrl);
      window.addEventListener('popstate', pushUrl);
      window.onpopstate = function(event) {
        console.log('location: ',document.location,', state: ',JSON.stringify(event.state))
      }*/
      
      
      if (!window.base_fetch) {
        window.base_fetch = fetch;
      }
      
      // Create a new fetch method that acts as a proxy
      fetchHook = function (url, options) {
        // You can add any custom logic here before making the actual fetch request
        // For example, you can modify headers or do additional processing
        
        // Call the original fetch method (window.base_fetch) with the provided arguments
        return window.base_fetch(url, options)
          .then((res) => {
            // Add your custom logic here after the fetch response is received
            // For example, you can log headers or do additional processing
            const headers = JSON.parse(res.headers.get('cors-received-headers'));
            console.log(headers);
            return res.json();
          });
      };
      
      // Redefine XMLHttpRequest to use the new fetch
      (function () {
        // Store the original XMLHttpRequest constructor
        var OldXMLHttpRequest = window.XMLHttpRequest;
      
        // Create a new XMLHttpRequest constructor
        function NewXMLHttpRequest() {
          var xhr = new OldXMLHttpRequest();
      
          // Replace the original xhr's send method with a custom implementation
          xhr.send = function () {
            // You can add any custom logic here before sending the request
            // For example, you can modify headers or do additional processing
      
            // Call the overridden fetch method and pass the arguments
            return window.base_fetch.apply(window, arguments);
          };
      
          return xhr;
        }
      
        // Replace the global XMLHttpRequest with the new constructor
        window.XMLHttpRequest = NewXMLHttpRequest;
      })();

      function corsProxyRequest(){ 
        
        this.proxy1 = "https://corsproxy.io/?";
        this.loading_new_page = false;
        this.x_loader = "";//window.x_loader;
      
        this.blobReciver = function(myResponse, myDest, member) {
          reader = new FileReader();
          //console.log("blob:",myBlob);
          new Promise((resolve, reject) => {
            var fr = new FileReader();  
            fr.onload = () => {
              //console.log("data-uri:",fr.result);
              myDest[member] = fr.result;       
            };
            fr.readAsDataURL(myResponse);
          }); 
        }
      
        this.textReciver = function(myText, myDest, member, uri) {
          //console.log("got text:",myText);
          //console.log(myDest,member);
          //console.log(myDest[member]);
          console.log("fixing textReciver:");
          console.log(member);
          console.log(myDest.getName);
          if(member == 'iframe'){
            var page;
            var loader = this.makeLoader(uri);
            var find_head = myText.match(/<\s*head[^>]*>/);
            if(find_head){
             // console.log(find_head);
              //console.log(find_head[0].length);
              //console.log(find_head.index);
              var head_pos = find_head[0].length+find_head.index;
              //console.log("head_pos",head_pos);
              //console.log(myText.substring(0,head_pos));
              //console.log("end of head_pos");
              page = myText.substring(0,head_pos) + loader + myText.substring(head_pos);
              //console.log(myText.substring(head_pos));
              console.log("new page:",page);
            }else{
              page = "<head>"+loader+"</head>"+myText;
            }
            //todo:  this is needed! 
            //myDest.write(page);
            //myDest.close();
            console.log(myDest.body);
          }else{
            myDest[member] = myText;
          }
        }
        //  blocked auto-focusing on <inpout>
        //https://stackoverflow.com/questions/63737458/blocked-autofocusing-on-a-input-element-in-a-cross-origin-subframe
      
        this.responseCallbackText = function(myResponse, myDest, member) {
           var uri = myResponse.url;
           if(typeof myResponse.headers['x-uri'] != 'undefined'){
              uri = myResponse.headers['x-uri'];
              console.log("Found X-URI:",uri);
           }
           return myResponse.text().then(myBlob => this.textReciver(myBlob, myDest, member, uri));
        }
      
        this.responseCallbackBlob = function(myResponse, myDest, member) {
           return myResponse.blob().then(myBlob => this.blobReciver(myBlob, myDest, member));
        }
        
        this.repairHost = function(uri){
          console.log("repairing to host:",uri);
          console.log("x_start:", window.x_start);
          if(uri.startsWith(window.x_start)){
            console.log("fixing:",uri);
            uri = uri.substring(window.x_start.length);
          }
          if(uri.startsWith("data://")){
            return uri;
          }
          if(!uri.startsWith("http")){
            var x_url = new URL(uri);
            if(uri.startsWith("/")){
              uri = "https://"+ x_url.host + uri;
            }else{
              uri = "https://"+ x_url.host + x_url.pathname + uri;
            }
          }
          console.log("fixed:",uri);
          return uri;
        }
      
        this.populateText = function(dom_dest, member, uri, method = "GET", body = ""){
          uri = this.repairHost(uri);
          method = method.toUpperCase();
          if(method == "GET"){
            var params = "";
            for (var key in body) {
                if (params != "") {
                    params += "&";
                }
                params += key + "=" + encodeURIComponent(body[key]);
            }
            uri = uri + "?" + params;
            fetch(uri).then(response => this.responseCallbackText(response, dom_dest, member));/*.catch(error => 
              fetch(this.proxy1+encodeURIComponent(uri)).then(response => this.responseCallbackText(response, dom_dest, member)).catch(error => 
                fetch(this.proxy2+encodeURIComponent(uri)).then(response => this.responseCallbackText(response, dom_dest, member))));*/
          }else{
            console.log("using method:", method);
            var req_attrib = {method: method, body: body, redirect: 'follow'};
              fetch(uri, req_attrib).then(response => this.responseCallbackText(response, dom_dest, member));/*.catch(error => 
                fetch(this.proxy1+encodeURIComponent(uri), req_attrib).then(response => this.responseCallbackText(response, dom_dest, member)).catch(error => 
                  fetch(this.proxy2+encodeURIComponent(uri), req_attrib).then(response => this.responseCallbackText(response, dom_dest, member))));*/
          }
        }
      
        this.populateBlob = function(dom_dest, member, uri){
          uri = this.repairHost(uri);
          fetch(uri).then(response => this.responseCallbackBlob(response, dom_dest, member));/*.catch(error => 
            fetch(this.proxy1+encodeURIComponent(uri)).then(response => this.responseCallbackBlob(response, dom_dest, member)).catch(error => 
              fetch(this.proxy2+encodeURIComponent(uri)).then(response => this.responseCallbackBlob(response, dom_dest, member))));*/
        }
        this.makeLoader = function(uri) {
          return "<head><base href='" + uri + "' /></head>" +
            "(function() {" +
            "  // Save the original postMessage function" +
            "  var originalPostMessage = window.postMessage;" +
            "  // Override the postMessage function" +
            "  window.postMessage = function(message, targetOrigin, transfer) {" +
            "    // Always set targetOrigin to '*'" +
            "    targetOrigin = '*';" +
            "    // Call the original postMessage function" +
            "    originalPostMessage.call(window, message, targetOrigin, transfer);" +
            "  };" +
            "})();" +
            "<script>window.x_uri='" + uri + "'; window.x_start='" + window.x_start + "';</" + "script>" +
            "<script id='x_loader'>" + window.x_loader + "</" + "script>";
        };
        this.popup = function(uri, method, body = ""){
          console.log("calling this.popup")
          var myiframe = document.createElement('iframe');
          myiframe.name = "navigator";
          myiframe.src = "about:blank";
          //myiframe.hostname="www.bing.com";
          //myiframe.hash="hash";
          //myiframe.search="test=123";    
          //myiframe.setAttribute("srcdoc", loader+text);
      
          myiframe.style.width = "100%";
          myiframe.style.height = "100%";
          myiframe.scrolling = "yes";
          //myiframe.onerror = function(e){console.log('caught iframe:',e)};
          myiframe.allow = "autoplay"
          myiframe.sandbox = "allow-pointer-lock allow-same-origin allow-scripts allow-orientation-lock allow-forms";
          
          document.body.appendChild(myiframe);
          var myiframeDoc = myiframe.contentWindow && myiframe.contentWindow.document;
          //myiframeDoc.body = document.createElement("body");
          myiframe.contentWindow.onerror=function(e) {
            console.log('caught iframe error!!', e);
            return false;
          }
          //document.body.appendChild(myiframe);
          proxy = corsProxyRequest();
      
          proxy.populateText(myiframeDoc, 'iframe', uri);
        }


    // Override createElement method to intercept and rewrite URLs
    document.createElement = (function (originalCreateElement) {
      return function (tagName) {
        var element = originalCreateElement.apply(this, arguments);

        // Intercepting 'a', 'img', 'script', and other elements with 'src' or 'href' attributes
        if (['a', 'img', 'script', /* Add other tags here if needed */].includes(tagName.toLowerCase())) {
          var originalSetAttribute = element.setAttribute;

          // Override setAttribute to rewrite 'src' or 'href' attributes
          element.setAttribute = function (name, value) {
            if ((tagName.toLowerCase() === 'a' && name.toLowerCase() === 'href') ||
                ((tagName.toLowerCase() === 'img' || tagName.toLowerCase() === 'script') && name.toLowerCase() === 'src')) {
              // Check if the URL is a relative hostname
              if (value.startsWith('/') || value.startsWith('./') || value.startsWith('../')) {
                // Construct a fully qualified domain name using window.xHost
                value = window.xHost + value;
              } else {
                // Otherwise, rewrite the URL using the cors_proxy variable
                value = window.cors_proxy + encodeURIComponent(value);
              }
            }
            originalSetAttribute.call(this, name, value);
          };
        }

        return element;
      };
    })(document.createElement);
        this.navigate = function(uri, method, body = ""){
          uri = this.repairHost(uri);
          console.log("navigating:", uri);
          //this.loading_new_page = true;
          var loader = this.makeLoader(uri);
          //document.getElementById('webpage').srcdoc = loader;
          console.log(loader);
         // x_load = document.createElement("script");
          //x_load.text = 
          window.x_uri = uri;
          //document.body = document.createElement("body");
          //this.populateText(document, 'innerHTML', uri, method, body);
          document.getElementByName("navigator").contentWindow = fetchWithProxy( window.x_uri);
          return document;
        }
      
        return this;
      }
    
    /*  
      fetch("pp.js").then(function(response) {
        response.text().then(function(text) {
            loader = `
            <html>
              <head>
                <base href="${window.x_uri}" target="_blank">
                <script>
                window.x_uri = "${window.x_uri}";
                window.x_start = "${window.x_start}";
              </`+`script>
              <script id=x_loader>
             //document.head.baseURI = URL(window.x_uri);
            window.x_cookie = {};
          `+text+`
          </`+`script>
          </head>`;
          fetchIframe("bad.html", loader);
          })
      });
      */
      /*
      const blobContent = new Blob(["<script>window.history.pushState(null, null, '/path?test=123');document.write(document.location)</"+"script>"], {type: "text/html"});
      console.log(blobContent);
      var iFrame = document.createElement("iframe");
      var srcobj = URL.createObjectURL(blobContent);
      srcobj.hostname="google.com";
      srcobj.hash="hash";
      srcobj.search="test=1337";
      iFrame.src = srcobj;
      document.body.appendChild(iFrame);
      */
      
      
      window.x_cors_service = false;

      function handleMessage(event) {
        console.log("got message:",event);
        if(typeof event.data["x_type"] != undefined){
          if(event.data["x_type"] == "navigate"){
            proxy = corsProxyRequest();
            //refresh about:blank:
            //event.source.frameElement.contentWindow.reload();
            //event.source.frameElement.contentWindow.location = "about:blank";
            //event.source.frameElement.src = "about:blank";
            //event.source.frameElement.contentWindow = "";
            console.log("myiframedoc:");
            console.log(window.myiframeDoc);
            //window.myiframeDoc = event.source.frameElement.contentWindow && event.source.frameElement.contentWindow.document;
            //todo clear out the iframe better...
           // window.myiframeDoc.body = document.createElement('body');
            //window.myiframeDoc.body.innerHTML = "";
            //var myiframeDoc = event.source.frameElement.contentWindow && event.source.frameElement.contentWindow.document;
            //proxy.populateText(event.source.frameElement, "iframe", event.data["x_uri"]);
            //proxy.populateText(myiframeDoc.body, "innerHTML", event.data["x_uri"]);
          }else if(event.data["x_type"] == "csw" && typeof event.data["x_id"] !== 'undefined'
                                             && typeof event.data["x_uri"] !== 'undefined'){
            if(window.x_cors_service){
              window.x_cors_lookup[event.data["x_id"]]=event.data["x_uri"];
            }else{
              //not for us, pass it up:
              parent.postMessage(event.data,"*");
            }
          }
        }
      }
      
      if ( window.addEventListener ) {
          window.addEventListener('message', handleMessage, false);
      } else if ( window.attachEvent ) { // ie8
          window.attachEvent('onmessage', handleMessage);
      }
      
      function createIFrame(iframeContent) {
          var myFrame = document.createElement("iframe");
          myFrame.src = "about:blank";
          //document.body.innerHTML = ""; // (optional) Totally Clear it if needed
          document.body.appendChild(myFrame);
          var myFrameDoc = myFrame.contentWindow && myFrame.contentWindow.document;
          if (!myFrameDoc) {
            console.log("iFrame security - about:blank failed");
            const blobContent = new Blob([iframeContent], {type: "text/html"});
            //console.log(blobContent);
            var myFrame = document.createElement("iframe");
            var srcobj = URL.createObjectURL(blobContent);
            srcobj.hostname="google.com";
            srcobj.hash="hash";
            srcobj.search="test=1337";
            //myFrame.src = srcobj;
            document.body.appendChild(myFrame);
            window.x_iframe = myFrame;   
          return;
          }
      
          //myFrameDoc.write(iframeContent);
          myFrameDoc.close();
      }      
/*
window.onerror = function (msg, url, lineNo, columnNo, error) {
  var string = msg.toLowerCase();
  var substring = "script error";
  if (string.indexOf(substring) > -1){
    alert('Script Error: See Browser Console for Detail');
  } else {
    var message = [
      'Message: ' + msg,
      'URL: ' + url,
      'Line: ' + lineNo,
      'Column: ' + columnNo,
      'Error object: ' + JSON.stringify(error)
    ].join(' - ');

    alert(message);
  }

  return false;
};
*/

//local storage pollyFill
  function isLocalStoragSupported() {
      return 'localStorage' in window && window['localStorage'] !== null;
  }
  
  if (!isLocalStoragSupported()) {
    function initLocalStore(undef) {
      var store = {
        setItem: function (id, val) {
          return store[id] = String(val);
        },
        getItem: function (id) {
          return store.hasOwnProperty(id) ? String(store[id]) : undef;
        },
        removeItem: function (id) {
          return delete store[id];
        },
        clear: function () {
          init();
        }
      };
      window.localStorage = store;
      window.sessionStorage = store;
    }
    initLocalStore();
  }
}

  //todo: this polyfill should only run in the top container.
  // Iframe polyfill - the child frame won't suspect a thing.
  /*
  Object.defineProperty(window, 'top', {
    get: function () {
      return window;
    },
    configurable: true
  });
  */

  Object.defineProperty(window, 'parent', {
    get: function () {
      return window;
    },
    configurable: true
  });
  //
// Function to wrap an existing onsubmit event handler
function wrapOnSubmit(form) {
  const originalOnSubmit = form.onsubmit;

  form.onsubmit = function (event) {
    // Your custom logic before the original onsubmit handler, if needed
    console.log('Before form submission');

    // Call the original onsubmit handler, if it exists
    if (originalOnSubmit && typeof originalOnSubmit === 'function') {
      originalOnSubmit(event);
    }

    // Your custom logic after the original onsubmit handler, if needed
    console.log('After form submission');
  };
}

// Function to wrap the very first event handler with submitRewrite
function wrapFirstEventHandler() {
  const forms = document.getElementsByTagName('form');

  // Check if DOMContentLoaded is registered
  if (typeof window.addEventListener === 'function') {
    window.addEventListener('DOMContentLoaded', function () {
      // Find the first form with an event handler (if any)
      for (let i = 0; i < forms.length; i++) {
        const form = forms[i];
        if (form.onsubmit) {
          const originalOnSubmit = form.onsubmit;

          form.onsubmit = function (event) {
            // Your custom logic before the original onsubmit handler, if needed
            console.log('Before form submission');

            // Call the original onsubmit handler, if it exists
            if (originalOnSubmit && typeof originalOnSubmit === 'function') {
              originalOnSubmit(event);
            }

            // Your custom logic after the original onsubmit handler, if needed
            console.log('After form submission');
          };
          return; // Stop after wrapping the first form's onsubmit
        }
      }

      // If no forms have an onsubmit handler, do something else
      if (forms.length > 0) {
        // Your custom logic when there's no existing onsubmit handler
        console.log('Form submitted with no existing onsubmit handler');
      }
    });
  }
}

// Function to handle the first load
function handleFirstLoad() {
  if (document.readyState === 'loading') {
    // The document is still loading, so we wait for the 'DOMContentLoaded' event
    document.addEventListener('DOMContentLoaded', function () {
      // Your code to run when the DOM is ready
      console.log('DOMContentLoaded event fired after the first readystatechange.');

      // Call wrapFirstEventHandler to wrap the first event handler
      wrapFirstEventHandler();
    });

    // Remove the 'readystatechange' event listener to ensure it's executed only once
    document.removeEventListener('readystatechange', handleFirstLoad);
  }
}

// Register the 'readystatechange' event listener to handle the first load
//document.addEventListener('readystatechange', handleFirstLoad);


  var localStorage = window.localStorage;
  var sessionStorage = window.sessionStorage;
  
  window.originalPush = window.history.pushState;
  try{
    if(window.x_uri){
      var myLoc = new URL(window.x_uri);
      window.originalPush.pushState(null, null, myLoc.pathname+myLoc.search+myLoc.hash);
    }
  }catch(e){}
  
  function corsProxyRequest(){ 
    this.proxy1 = "https://www.whateverorigin.org/get?url=";
    this.loading_new_page = false;
    this.x_loader = document.getElementById("x_loader").innerHTML;
  
    this.blobReciver = function(myResponse, myDest, memeber) {
      reader = new FileReader();
      //console.log("blob:",myBlob);
      new Promise((resolve, reject) => {
        var fr = new FileReader();  
        fr.onload = () => {
            cors_read = JSON.parse(fr.result);
          myDest[member] = cors_read.contents;
        };
        fr.readAsDataURL(myBlob);
      }); 
    }
  
    this.textReciver = function(myText, myDest) {
        myDest = myText;
    }
  
    this.responseCallbackBlob = function(myResponse, myDest, member) {
       return myResponse.blob().then(myBlob => this.blobReciver(myBlob, myDest, member));
    }
    
    this.repairHost = function(uri){
      if(uri.startsWith("data://")){
        return uri;
      }
      if(!uri.startsWith("http")){
        uri = document.head.baseURI + uri;
      }
      return uri;
    }
  
    this.populateText = function(uri, dom_dest, member){
      uri = this.repairHost(uri);
      fetch(uri).then(response => this.textReciver(response, dom_dest, member)).catch(error => 
        fetch(this.proxy1+uri).then(response => this.textReciver(response, dom_dest, member)));
    }
  
    this.populateBlob = function(uri, dom_dest, member){
      uri = this.repairHost(uri);
      fetch(uri).then(response => this.responseCallbackBlob(response, dom_dest, member)).catch(error => 
        fetch(this.proxy1+uri).then(response => this.responseCallbackBlob(response, dom_dest, member)));
    }
  
    this.makeHead= function(uri){
      return '<base href="'+uri+'" target="_blank"></base><script>window.x_uri="'+uri+'";</'+'script><script id=x_loader>'+this.x_loader+'</'+'script>';
    }
    
    this.navigate = function(uri){
      //Change the hash, enable back button:
      history.pushState(null, null, '#' + uri);
      //this.loading_new_page = true;
      document.body.innerHTML = "";
      document.head.innerHTML = this.makeHead(uri);
      this.populateText(uri, document, 'body')
    }
    return this;
  }
  

// Create a new MutationObserver
const observer = new MutationObserver((mutationsList, observer) => {
  // Loop through mutations
  for (const mutation of mutationsList) {
    // Check if nodes were added to the DOM
    if (mutation.type === 'childList' && mutation.addedNodes.length > 0) {
      // Loop through added nodes
      for (const node of mutation.addedNodes) {
        // Check if the added node is an <a> tag
        if (node.tagName && node.tagName.toLowerCase() === 'a') {
          // Do something with the newly created <a> tag
          console.log('New <a> tag created:', node);
          
          // You can add your custom logic here to modify or handle the <a> tag.
        }
      }
    }
  }
});


  /*
  window.history.pushState = function(state, title, url){
    console.log("hooked history:",state, title, url);
    proxy = corsProxyRequest();
    proxy.navigate(url);
  };    
  */    

// Start observing changes in the document
//observer.observe(document, { childList: true, subtree: true });

  function fixSource(event){
    if ( event.target && event.target.tagName){
      var proxy = corsProxyRequest();
      console.log(event.target.tagName);
      console.log(event.target);
      const tagName = event.target.tagName.toLowerCase();
      if(tagName == 'link' && event.target.rel && "style" == event.target.rel.toLowerCase().substring(0,5) && event.target.href && !event.target.href.startsWith("data")){
        var myStyle = document.createElement('style');
        myStyle.innerHTML=myText;
        document.head.append(myStyle);       
        proxy.populateText(event.target.href, myStyle, 'innerHTML'); 
      }else if(typeof event.target.src !== 'undefined' && !event.target.src.startsWith("data")){
        if(tagName == 'iframe'){
          var target_uri = event.target.src;
          event.target.src = "";
          event.target.srcdoc = "";
          proxy.populateText(target_uri, event.target, 'srcdoc');          
        }else{
          proxy.populateText(event.target.src, event.target, 'src'); 
       /* }else if(typeof event.target.href !==undefined){
            proxy.populateText(event.target.href, event.target); 
        }*/
        }
      }
    }
  }

  /*
  document.addEventListener('load', function(event) {
    console.log("caught load:",event);
    fixSource(event);
  }, true);
  
  document.addEventListener('error', function(event) {
    console.log("caught error:",event);
    fixSource(event);
  }, true);
  */
  openPageHandler = function(e){
    console.log("hooked open:",hook);
    e.cancelBubble = true;
    if (e.stopPropagation) e.stopPropagation();
    if (e.preventDefault) e.preventDefault();
    var myiframe = document.createElement('iframe');
    document.body.appendChild(iframe);
    proxy = corsProxyRequest();
    proxy.populateText(e.target.href, myiframe, 'srcdoc');
    return myiframe;
  };
  
  onclickHandler = function (e) {
    console.log("hooked onclick");
    e = e ||  window.event;
    var element = e.target || e.srcElement;
    //# is sometimes used as a placeholder for an onclick...
    if (element.tagName == 'A' && element.href && !element.href.startsWith("#") && !element.href.startsWith('javscript')) {
      console.log("processing:", element.href);
      //stop the default action.
      e.cancelBubble = true;
      if (e.stopPropagation) e.stopPropagation();
      if (e.preventDefault) e.preventDefault(); 
  
      proxy = corsProxyRequest();
      if(typeof element.target !== 'undefined' && element.target.toLowerCase() == "_blank"){
        proxy.popup(element.href);
      }else{    
        proxy.navigate(element.href);
      }     
      return false; // prevent default action and stop event propagation
    }
  };

        const backButton = document.getElementById('back-button');
        const forwardButton = document.getElementById('forward-button');
        const refreshButton = document.getElementById('refresh-button');
        const urlInput = document.getElementById('url-input');
        const webpage = document.getElementById('webpage');
        const historyStack = [];
        let currentIndex = -1;

        backButton.addEventListener('click', () => {
            if (currentIndex > 0) {
                currentIndex--;
                forwardButton.disabled = false;
                urlInput.value = historyStack[currentIndex];
                webpage.src = historyStack[currentIndex];
            }
            backButton.disabled = currentIndex === 0;
        });

        forwardButton.addEventListener('click', () => {
            if (currentIndex < historyStack.length - 1) {
                currentIndex++;
                backButton.disabled = false;
                urlInput.value = historyStack[currentIndex];
                webpage.src = historyStack[currentIndex];
            }
            forwardButton.disabled = currentIndex === historyStack.length - 1;
        });

        refreshButton.addEventListener('click', () => {
            webpage.src = urlInput.value;
        });

        urlInput.addEventListener('keyup', (event) => {
            if (event.key === 'Enter') {
                const url = urlInput.value;
                webpage.src = url;
                if (url !== historyStack[currentIndex]) {
                    historyStack.push(url);
                    currentIndex++;
                }
                backButton.disabled = currentIndex === 0;
                forwardButton.disabled = true;
            }
        });

        // Add event listener to track iframe navigation
        webpage.addEventListener('load', () => {
            if (webpage.src !== historyStack[currentIndex]) {
                historyStack.push(webpage.src);
                currentIndex++;
            }
            backButton.disabled = currentIndex === 0;
            forwardButton.disabled = true;
        });

        // Keep address bar at the top while scrolling
        const chromeBar = document.getElementById('chrome-bar');
        const content = document.getElementById('content');
        const webpageHeight = document.getElementById('webpage').clientHeight;

        content.addEventListener('scroll', () => {
            const scrollTop = content.scrollTop;
            if (scrollTop >= webpageHeight) {
                chromeBar.style.top = `${scrollTop - webpageHeight}px`;
            } else {
                chromeBar.style.top = '0';
            }
        });
        window.loader =`<html>
          <head>
            <base href="${window.x_uri}" target="_blank">
            <script>
            window.x_uri = "${window.x_uri}";
            window.x_start = "${window.x_start}";
          </`+`script>
          <`+`script id=x_loader>
         //document.head.baseURI = URL(window.x_uri);
        window.x_cookie = {};
      `+window.x_loader+`<`+`/head>`    

      function fetchIframe(url, loader){
        fetch(url).then(function(response) {
          response.text().then(function(iframeContent) {
              var pollFrame = document.createElement("iframe");
              
             // const blobContent = new Blob([loader+iframeContent], {type: "text/html"});
              //var srcobj = URL.createObjectURL(blobContent);  
              //pollFrame.src = srcobj;      
              
              pollFrame.src = "about:blank";
              //pollFrame.hostname="www.bing.com";
              //pollFrame.hash="hash";
              //pollFrame.search="test=123";        
              
              //pollFrame.setAttribute("srcdoc", loader+text);
              
              pollFrame.style.width = "640px";
              pollFrame.style.height = "480px";
              pollFrame.scrolling = "yes";
              pollFrame.onerror = function(e){console.log('caught iframe:',e)};
              pollFrame.allow="autoplay"
              pollFrame.sandbox = "allow-pointer-lock allow-same-origin allow-scripts allow-orientation-lock allow-forms";
              
              document.body.appendChild(pollFrame);
              var pollFrameDoc = pollFrame.contentWindow && pollFrame.contentWindow.document;
              
              pollFrameDoc.write(loader+iframeContent);
              pollFrame.contentWindow.onerror=function(e) {
                console.log('caught iframe error!!', e);
                return false;
              }
          });
        });
      }

      /*
// i don't htnk this is needed:

      function updateElementAttributes(element) {
        // Check if the element is 'a', 'img', 'script', or any other tag you want to modify
        if (element.tagName.toLowerCase() === 'a' || 
            element.tagName.toLowerCase() === 'img' || 
            element.tagName.toLowerCase() === 'script') {
          
          // Check and modify 'src' attribute for 'img' and 'script' tags
          // Check and modify 'href' attribute for 'a' tags
          const srcAttribute = element.tagName.toLowerCase() === 'a' ? 'href' : 'src';
      
          // Get the current attribute value
          let value = element.getAttribute(srcAttribute);
          if(value == "'/service-worker.js'"){
            // no change
            return;
          }
          // Check if it's a relative hostname
          if (value && (value.startsWith('/') || value.startsWith('./') || value.startsWith('../'))) {
            // Construct a fully qualified domain name using window.xHost
            value = window.xHost + value;
          } else {
            // Otherwise, rewrite the URL using the cors_proxy variable
            value = window.x_proxy + encodeURIComponent(value);
          }
      
          // Update the attribute value
          element.setAttribute(srcAttribute, value);
        }
      }
      
      // Traverse all existing elements on the page and update their attributes
      document.querySelectorAll('*').forEach(updateElementAttributes);
      */currentIndex

      document.addEventListener('DOMContentLoaded', function() {
        window.x_uri = document.getElementById('webpage').value;
        if(window.x_uri){
          console.log("going to:"+window.x_uri);
          fetchIframe(window.x_proxy+window.x_uri);
          window.addEventListener('hashchange', function () {
            var message = window.location.hash.substring(1);
            // Process the message
        }); 
      }
     });
    
    </script> 
</body>
</html>
